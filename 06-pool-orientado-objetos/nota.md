1. Introducción a la Programación Orientada a Objetos (POO)

Concepto de clase y objeto: Comprender la diferencia entre una plantilla (clase) y una instancia (objeto)
Atributos y métodos: Datos y comportamientos que definen un objeto
Constructores: Cómo se inicializan los objetos
Getters y setters: Acceder y modificar propiedades de forma controlada

2. Pilares de la POO

Encapsulamiento: Ocultar los detalles internos de implementación
Herencia: Crear nuevas clases basadas en clases existentes
Polimorfismo: Tratar objetos de diferentes clases a través de una interfaz común
Abstracción: Modelar entidades complejas centrándose en lo relevante

3. Conceptos Avanzados de POO

Clases abstractas: Plantillas parcialmente implementadas que no pueden instanciarse
Interfaces: Contratos que definen comportamientos sin implementación
Composición vs. herencia: Cuándo es preferible la relación "tiene un" sobre "es un"
Sobrecarga y sobreescritura: Diferentes formas de especializar comportamientos

4. Diseño de Software

UML: Diagramas para visualizar la estructura de clases
Acoplamiento y cohesión: Medir y mejorar las relaciones entre componentes
Ley de Demeter: Principio de menor conocimiento para reducir dependencias
Responsabilidad única (introducción): Primera aproximación al concepto SRP

5. Patrones de Diseño

Patrones creacionales: Factory, Builder, Singleton, etc.
Patrones estructurales: Adapter, Composite, Decorator, etc.
Patrones de comportamiento: Strategy, Observer, Command, etc.
Inyección de dependencias: Técnica fundamental para la inversión de control

6. Calidad de Código y Refactorización

Code smells: Identificar señales de problemas en el diseño
Deuda técnica: Reconocer y gestionar compromisos en la calidad
Refactorización: Mejorar el diseño sin cambiar comportamiento
Testing: Pruebas unitarias, TDD (Test Driven Development)

7. Principios SOLID
   Ahora sí, estás preparado para aprender y aplicar los principios SOLID:

S: Principio de Responsabilidad Única
O: Principio de Abierto/Cerrado
L: Principio de Sustitución de Liskov
I: Principio de Segregación de Interfaces
D: Principio de Inversión de Dependencias

8. Arquitectura de Software

Arquitectura en capas: Presentación, lógica de negocio, datos
Arquitectura hexagonal/puertos y adaptadores: Independencia del framework
Microservicios vs. monolito: Diferentes enfoques arquitectónicos
DDD (Domain-Driven Design): Diseño orientado al dominio
